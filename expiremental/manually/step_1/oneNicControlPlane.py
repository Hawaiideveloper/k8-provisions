#!/usr/bin/env python3

import os
import subprocess
from datetime import datetime

# Comprehensive list of reliable and free NTP servers
NTP_SERVERS = [
    "server 0.pool.ntp.org iburst",
    "server 1.pool.ntp.org iburst",
    "server 2.pool.ntp.org iburst",
    "server 3.pool.ntp.org iburst",
    "server time.google.com iburst",
    "server time.cloudflare.com iburst",
    "server time.apple.com iburst",
    "server time.windows.com iburst"
]

# Function to execute shell commands and handle errors
def run_command(command, error_message):
    try:
        subprocess.run(command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except subprocess.CalledProcessError as e:
        print(f"{error_message}\n{e.stderr.decode()}")
        exit(1)

# Function to check if a command exists
def command_exists(cmd):
    return subprocess.run(["which", cmd], stdout=subprocess.PIPE, stderr=subprocess.PIPE).returncode == 0

# Function to install NTP
def install_ntp():
    print("Installing NTP...")
    if command_exists("apt"):
        run_command(["sudo", "apt", "update"], "Failed to update package lists.")
        run_command(["sudo", "apt", "install", "-y", "ntp"], "Failed to install NTP.")
    elif command_exists("yum"):
        run_command(["sudo", "yum", "install", "-y", "ntp"], "Failed to install NTP.")
    elif command_exists("dnf"):
        run_command(["sudo", "dnf", "install", "-y", "ntp"], "Failed to install NTP.")
    else:
        print("Unsupported package manager. Please install NTP manually.")
        exit(1)

# Function to backup existing NTP configuration
def backup_ntp_config(ntp_conf):
    if os.path.exists(ntp_conf):
        print("Backing up existing NTP configuration...")
        backup_file = f"{ntp_conf}.bak_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}"
        run_command(["sudo", "cp", ntp_conf, backup_file], "Failed to backup the NTP configuration.")

# Function to write new NTP configuration
def write_ntp_config(ntp_conf):
    print("Configuring NTP servers...")
    try:
        config_lines = ["# NTP configuration generated by script"] + NTP_SERVERS
        with open("temp_ntp.conf", "w") as temp_file:
            temp_file.write("\n".join(config_lines) + "\n")
        run_command(["sudo", "mv", "temp_ntp.conf", ntp_conf], "Failed to write the NTP configuration.")
    except Exception as e:
        print(f"Error while writing configuration: {e}")
        exit(1)

# Function to restart NTP service
def restart_ntp_service():
    print("Restarting NTP service...")
    run_command(["sudo", "systemctl", "restart", "ntp"], "Failed to restart the NTP service.")
    run_command(["sudo", "systemctl", "enable", "ntp"], "Failed to enable the NTP service on boot.")

# Configuration
adapters = ["ens34"]  # List of network adapters to configure
config_file = "/etc/netplan/01-netcfg.yaml"  # Path to the netplan configuration file
hostname = "k8-controlplane"  # Correct hostname for the Kubernetes control plane
nameserver = "172.100.55.2"  # Desired nameserver for DNS resolution

def run_command(command, ignore_errors=False):
    """
    Runs a shell command and returns its output.
    Handles errors if the command fails.
    """
    try:
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        if not ignore_errors:
            print(f"Error running command '{' '.join(command)}': {e.stderr.strip()}")
        return None

def remove_kubernetes_tools():
    """
    Checks for and removes existing Kubernetes tools (kubeadm, kubectl, kubelet).
    """
    print("Checking and removing existing Kubernetes tools if found...")
    tools = ["kubeadm", "kubectl", "kubelet"]
    for tool in tools:
        tool_path = run_command(["which", tool], ignore_errors=True)
        if tool_path:
            print(f"{tool} found at {tool_path}. Removing...")
            run_command(["apt", "purge", "-y", tool])
            run_command(["apt", "autoremove", "-y"])
            print(f"{tool} and related dependencies have been removed.")
        else:
            print(f"{tool} not found. Assuming it has already been removed.")

    # Remove Kubernetes-related directories
    directories = ["/etc/kubernetes", "/var/lib/kubelet"]
    for directory in directories:
        if os.path.exists(directory):
            print(f"Removing directory: {directory}")
            run_command(["rm", "-rf", directory])

    print("Kubernetes tools and related components cleaned up.")

def configure_dns():
    """
    Configures DNS to use the specified nameserver.
    """
    print(f"Setting nameserver to {nameserver}...")
    resolv_conf = "/etc/resolv.conf"
    with open(resolv_conf, "w") as resolv_file:
        resolv_file.write(f"nameserver {nameserver}\n")
    print("DNS configured successfully.")

def disable_ipv6():
    """
    Disables IPv6 permanently.
    """
    print("Disabling IPv6 permanently...")
    sysctl_conf = "/etc/sysctl.d/99-sysctl.conf"
    ipv6_config = [
        "net.ipv6.conf.all.disable_ipv6 = 1",
        "net.ipv6.conf.default.disable_ipv6 = 1"
    ]
    
    # Add IPv6 disable configuration if not already present
    with open(sysctl_conf, "a") as sysctl_file:
        for line in ipv6_config:
            sysctl_file.write(line + "\n")

    # Apply sysctl changes
    run_command(["sysctl", "--system"])
    print("IPv6 successfully disabled.")

def disable_swap():
    """
    Disables swap memory to comply with Kubernetes requirements.
    """
    print("Disabling swap...")
    run_command(['swapoff', '-a'])
    with open("/etc/fstab", "r+") as fstab:
        lines = fstab.readlines()
        fstab.seek(0)
        for line in lines:
            if "swap" not in line:
                fstab.write(line)
        fstab.truncate()
    print("Swap has been disabled.")

def set_hostname():
    """
    Sets the hostname of the machine, updates /etc/hosts with 127.0.1.1 and the actual IP address of ens34.
    """
    print(f"Setting hostname to {hostname}...")
    try:
        # Set the hostname
        run_command(['hostnamectl', 'set-hostname', hostname])

        # Get the IP address of ens34
        ens34_ip = run_command(['ip', '-o', '-4', 'addr', 'show', 'ens34']).split()[3].split('/')[0]

        # Update /etc/hosts
        hosts_file_path = "/etc/hosts"
        with open(hosts_file_path, "r") as hosts_file:
            lines = hosts_file.readlines()

        # Check if entries already exist and update if necessary
        updated_127 = False
        updated_ens34 = False
        with open(hosts_file_path, "w") as hosts_file:
            for line in lines:
                if "127.0.1.1" in line and hostname in line:
                    hosts_file.write(f"127.0.1.1 {hostname}\n")
                    updated_127 = True
                elif ens34_ip in line and hostname in line:
                    hosts_file.write(f"{ens34_ip} {hostname}\n")
                    updated_ens34 = True
                else:
                    hosts_file.write(line)

            # Add missing entries
            if not updated_127:
                hosts_file.write(f"127.0.1.1 {hostname}\n")
            if not updated_ens34:
                hosts_file.write(f"{ens34_ip} {hostname}\n")

        print(f"Hostname set to {hostname}, and /etc/hosts updated with 127.0.1.1 and {ens34_ip}.")
    except Exception as e:
        print(f"Failed to set hostname or update /etc/hosts: {e}")


def update_system():
    """
    Updates all system packages to the latest versions.
    """
    print("Updating system packages...")
    run_command(['apt', 'update'])
    run_command(['apt', 'upgrade', '-y'])
    print("System packages have been updated.")

def configure_firewall():
    """
    Configures the UFW firewall to allow necessary Kubernetes ports.
    """
    print("Configuring firewall for Kubernetes ports...")
    k8s_ports = [
        "6443",    # Kubernetes API server
        "8080",    #API group list
        "2379:2380",  # etcd server client API
        "10250",   # Kubelet API
        "10251",   # kube-scheduler
        "10252",    # kube-controller-manager  
        "10255",   # Read-only Kubelet API
        "30000:32767"  # NodePort Services


    ]
    for port in k8s_ports:
        run_command(['ufw', 'allow', port + '/tcp'], ignore_errors=True)
    run_command(['ufw', 'enable'], ignore_errors=True)
    print("Firewall configured for Kubernetes ports.")

# def remove_default_routes():
#     """
#     Removes specific default routes as required for Kubernetes network setup.
#     """
#     print("Removing specific default routes...")
#     for adapter, gateway in routes_to_remove.items():
#         result = run_command(['ip', 'route', 'del', 'default', 'via', gateway, 'dev', adapter], ignore_errors=True)
#         if result is not None:
#             print(f"Removed default route via {gateway} on {adapter}")
#         else:
#             print(f"Route via {gateway} on {adapter} not present. Skipping.")

def verify_kubeadm_preflight():
    """
    Verifies kubeadm preflight checks.
    """
    print("Running kubeadm preflight checks...")
    if run_command(["which", "kubeadm"], ignore_errors=True):
        result = run_command(['kubeadm', 'config', 'images', 'pull'], ignore_errors=True)
        if result is not None:
            print("Preflight checks passed. Images pulled successfully.")
        else:
            print("Preflight checks failed. Verify kubeadm readiness.")
    else:
        print("kubeadm is not installed. Skipping preflight checks.")

def main():
    """
    Main function to setup the machine for Kubernetes.
    """
    if os.geteuid() != 0:
        print("This script must be run as root. Please try again with 'sudo'.")
        return

    update_system()  # Update system packages
    remove_kubernetes_tools()  # Remove existing Kubernetes tools if found
    configure_dns()  # Configure DNS
    disable_ipv6()  # Disable IPv6 permanently
    set_hostname()  # Set system hostname
    disable_swap()  # Disable swap
    configure_firewall()  # Setup firewall
    verify_kubeadm_preflight()  # Run kubeadm preflight checks

if __name__ == "__main__":
    main()


print("echo now printing main function dupicate")

# Main function
def main():
    ntp_conf = "/etc/ntp.conf"

    # Check if NTP is installed
    if not command_exists("ntpd"):
        install_ntp()

    # Backup existing configuration
    backup_ntp_config(ntp_conf)

    # Write new configuration
    write_ntp_config(ntp_conf)

    # Restart NTP service
    restart_ntp_service()

    # Verify status
    print("NTP setup completed. Current status:")
    run_command(["sudo", "systemctl", "status", "ntp", "--no-pager"], "Failed to check the NTP service status.")

if __name__ == "__main__":
    main()





    #!/usr/bin/env python3

import os
import subprocess
from datetime import datetime

# Comprehensive list of reliable and free NTP servers
NTP_SERVERS = [
    "server 0.pool.ntp.org iburst",
    "server 1.pool.ntp.org iburst",
    "server 2.pool.ntp.org iburst",
    "server 3.pool.ntp.org iburst",
    "server time.google.com iburst",
    "server time.cloudflare.com iburst",
    "server time.apple.com iburst",
    "server time.windows.com iburst"
]

# Function to execute shell commands and handle errors
def run_command(command, error_message=None, ignore_errors=False):
    try:
        result = subprocess.run(command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        if not ignore_errors:
            print(f"{error_message or 'Error'}: {e.stderr.strip()}")
        return None

# Check if a command exists
def command_exists(cmd):
    return run_command(["which", cmd], ignore_errors=True) is not None

# Install NTP
def install_ntp():
    print("Installing NTP...")
    if command_exists("apt"):
        run_command(["sudo", "apt", "update"], "Failed to update package lists.")
        run_command(["sudo", "apt", "install", "-y", "ntp"], "Failed to install NTP.")
    elif command_exists("yum"):
        run_command(["sudo", "yum", "install", "-y", "ntp"], "Failed to install NTP.")
    elif command_exists("dnf"):
        run_command(["sudo", "dnf", "install", "-y", "ntp"], "Failed to install NTP.")
    else:
        print("Unsupported package manager. Please install NTP manually.")
        exit(1)

# Backup NTP configuration
def backup_ntp_config(ntp_conf):
    if os.path.exists(ntp_conf):
        print("Backing up existing NTP configuration...")
        backup_file = f"{ntp_conf}.bak_{datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}"
        run_command(["sudo", "cp", ntp_conf, backup_file], "Failed to backup the NTP configuration.")

# Write new NTP configuration
def write_ntp_config(ntp_conf):
    print("Configuring NTP servers...")
    try:
        config_lines = ["# NTP configuration generated by script"] + NTP_SERVERS
        with open("temp_ntp.conf", "w") as temp_file:
            temp_file.write("\n".join(config_lines) + "\n")
        run_command(["sudo", "mv", "temp_ntp.conf", ntp_conf], "Failed to write the NTP configuration.")
    except Exception as e:
        print(f"Error while writing configuration: {e}")
        exit(1)

# Restart NTP service
def restart_ntp_service():
    print("Restarting NTP service...")
    run_command(["sudo", "systemctl", "restart", "ntp"], "Failed to restart the NTP service.")
    run_command(["sudo", "systemctl", "enable", "ntp"], "Failed to enable the NTP service on boot.")

# Main function
def main():
    ntp_conf = "/etc/ntp.conf"

    # Check if NTP is installed
    if not command_exists("ntpd"):
        install_ntp()

    # Backup existing configuration
    backup_ntp_config(ntp_conf)

    # Write new configuration
    write_ntp_config(ntp_conf)

    # Restart NTP service
    restart_ntp_service()

    # Verify status
    print("NTP setup completed. Current status:")
    run_command(["sudo", "systemctl", "status", "ntp", "--no-pager"], "Failed to check the NTP service status.")

    # Additional setup tasks
    print("Disabling IPv6...")
    run_command(["sudo", "sysctl", "-w", "net.ipv6.conf.all.disable_ipv6=1"], "Failed to disable IPv6.")
    run_command(["sudo", "sysctl", "-w", "net.ipv6.conf.default.disable_ipv6=1"], "Failed to disable default IPv6.")

    print("Configuring firewall...")
    firewall_ports = ["6443", "2379:2380", "10250", "10255"]
    for port in firewall_ports:
        run_command(["sudo", "ufw", "allow", f"{port}/tcp"], "Failed to configure firewall.", ignore_errors=True)
    run_command(["sudo", "ufw", "enable"], "Failed to enable UFW.", ignore_errors=True)

if __name__ == "__main__":
    if os.geteuid() != 0:
        print("This script must be run as root. Please use 'sudo'.")
    else:
        main()
